var documenterSearchIndex = {"docs":
[{"location":"#AddToField.jl","page":"Introduction","title":"AddToField.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Julia macros to easily construct named tuples and set properties of mutable structures. AddToField.jl exports two macros, @addnt, for constructing NamedTuples and @addto! for modifiying existing data structures. Github repo here.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To create NamedTuples, use @addnt:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using AddToField;\n\njulia> @addnt begin \n           @add a = 1\n           @add b = a + 2\n       end\n(a = 1, b = 3)\n\njulia> @addnt begin \n           @add \"Variable a\" a = 1\n           @add b = a + 2\n       end\n(Variable a = 1, b = 3)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To modify existing structures, use @addto!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> D = Dict();\n\njulia> @addto! D begin \n           @add a = 1\n           @add b = a + 2\n           @add \"Variable c\" c = b + 3\n       end\nDict{Any,Any} with 3 entries:\n  :a                   => 1\n  :b                   => 3\n  Symbol(\"Variable c\") => 6","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"AddToField makes working with DataFrames easier. First, makes the creation of publication-quality tables easier. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using DataFrames, PrettyTables, Chain\njulia> df = DataFrame(\n           group = repeat(1:2, 50),\n           income_reported = rand(100),\n           income_imputed = rand(100));\n\njulia> @chain df begin \n           groupby(:group)\n           combine(_; keepkeys = false) do d\n               @addnt begin \n                   @add \"Group\" first(d.group)\n                   @add \"Mean reported income\" m_reported = mean(d.income_reported)\n                   @add \"Mean imputed income\" m_imputed = mean(d.income_imputed)\n                   @add \"Difference\" m_reported - m_imputed\n               end\n           end\n           pretty_table(;nosubheader = true)\n       end\n┌───────┬──────────────────────┬─────────────────────┬────────────┐\n│ Group │ Mean reported income │ Mean imputed income │ Difference │\n├───────┼──────────────────────┼─────────────────────┼────────────┤\n│     1 │             0.523069 │             0.53696 │ -0.0138915 │\n│     2 │             0.473178 │             0.41845 │  0.0547277 │\n└───────┴──────────────────────┴─────────────────────┴────────────┘","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It also makes constructing data frames easier","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using DataFrames\n\njulia> df = DataFrame();\n\njulia> @addto! df begin\n           x = [\"a\", \"b\", \"c\"]\n           @add x = x .* \"_x\"\n           @add x_y = x .* \"_y\"\n       end\n3×2 DataFrame\n Row │ x       x_y    \n     │ String  String \n─────┼────────────────\n   1 │ a_x     a_x_y\n   2 │ b_x     b_x_y\n   3 │ c_x     c_x_y\n","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nYou cannot use @add in new scopes created with body. The following will fail@addnt begin\n  let\n      a = 1\n      @add a\n  end\nendThis is because @addnt and @addto! create anonymous variables, then constructs and modifies objects at the end of the block. The same applies for for loops and functions  inside the @addnt and  @addto! blocks. In theory, @addto! should not have this limitation.  However I implementing this feature in @addnt is more complicated,  and At the moment maintaining simple feature parity is important. ","category":"page"},{"location":"api/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"@addnt","category":"page"},{"location":"api/api/#AddToField.@addnt","page":"API","title":"AddToField.@addnt","text":"@addnt(body)\n\nCreate a named tuple using @add statments inside body.\n\nUsage\n\nWithin body, you can create a namedtuple with the following syntaxes.\n\n@add x: The named tuple will contain the field :x with the value of x.\n@add x, y, z: The named tuple will contain the fields x, y, and z with  their corresponding values.\n@add x = expr: The named tuple will contain the field :x with the value of  expr. The variable x will still be created.\n@add \"My value\" x: The named tuple will contain the field Symbol(\"My value)  with the value of x. You can also interpolate values inside the String  name.\n@add \"My value\" x = expr: The named tuple will contain the field  Symbol(\"My value\") with the value of expr. The variable x will still be created.\n\n@addnt begin ... end does not create a new scope, meaning changes all variable assignments in the inside the expression modify the existing scope. To create a new scope, use @addnt let ... end.\n\nExample:\n\njulia> s = \"My long name\";\n\njulia> res = @addnt begin\n\t\ta = 1\n\t\t@add a\n\n\t\tf, g, h = 6, 7, 8\n\t\t@add f, g, h\n\n\t\t@add b = 2\n\t\t@add :c1 c = 3\n\t\t@add \"d1\" d = 4\n\t\t@add \"My long name\" e = 5\n\tend\nend\n(a = 1, f = 6, g = 7, h = 8, b = 2, c1 = 3, d1 = 4, My long name = 5)\n\njulia> @addnt let\n           @add local_var = 500\n       end\n(local_var = 500,)\n\njulia> isdefined(Main, :local_var)\nfalse\n\nnote: Note\nYou cannot use @add in new scopes created with body. The following will fail@addnt begin\n\tlet\n\t    a = 1\n\t    @add a\n\tend\nendThis is because @addnt creates anonymous variables, then constructs the named tuple at the end of the expression. The same applies for for loops and functions inside the @addnt and @addto! blocks.\n\n\n\n\n\n","category":"macro"},{"location":"api/api/","page":"API","title":"API","text":"@addto!","category":"page"},{"location":"api/api/#AddToField.@addto!","page":"API","title":"AddToField.@addto!","text":"@addto!(x, body)\n\nSet properties or indices of x using @add statments inside body.\n\nUsage\n\nWithin body, you can add properies or indices of x with the following.\n\n@add x: The named tuple will contain the field :x with the value of x.\n@add x, y, z: The named tuple will contain the fields x, y, and z  with their corresponding values.\n@add x = expr: The named tuple will contain the field :x with the value of  expr. The variable x will still be created.\n@add \"My value\" x: The named tuple will contain the field Symbol(\"My value)  with the value of x. You can also interpolate values inside the String  name.\n@add \"My value\" x = expr: The named tuple will contain the field  Symbol(\"My value\") with the value of expr. The variable x will still be created.\n\n@addto! defaults to calling setproperty! on x. However with AbstractDict, it calls setindex! with Symbols. Wieh AbstractDict{<:AbstractString} is calls setindex! with Strings.\n\n@addto! d begin ... end does not create a new scope, meaning changes all variable assignments in the inside the expression modify the existing scope. To create a new scope, use @addto! d let ... end.\n\nExample:\n\njulia> D = Dict();\n\njulia> s = \"My long name\";\n\njulia> res = @addto! D begin\n\t\ta = 1\n\t\t@add a\n\n\t\tf, g, h = 6, 7, 8\n\t\t@add f, g, h\n\n\t\t@add b = 2\n\t\t@add :c1 c = 3\n\t\t@add \"d1\" d = 4\n\t\t@add \"My long name\" e = 5\n\tend\nend\nDict{Any,Any} with 8 entries:\n  :a                     => 1\n  :f                     => 6\n  :b                     => 2\n  :h                     => 8\n  :g                     => 7\n  :d1                    => 4\n  :c1                    => 3\n  Symbol(\"My long name\") => 5\n\njulia> @addto! d let\n           @add local_var = 500\n       end;\n\njulia> isdefined(Main, :local_var)\nfalse\n\nnote: Note\nYou cannot use @addto! in new scopes created with body. The following will fail@addto! D begin\n\tlet\n\t    a = 1\n\t    @add a\n\tend\nendThis is because @addto! creates anonymous variables, then constructs the setproperty! or setindex! calls at the end of the expression.\n\n\n\n\n\n","category":"macro"}]
}
