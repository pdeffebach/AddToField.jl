var documenterSearchIndex = {"docs":
[{"location":"#AddToField.jl","page":"AddToField.jl","title":"AddToField.jl","text":"","category":"section"},{"location":"","page":"AddToField.jl","title":"AddToField.jl","text":"@addnt","category":"page"},{"location":"#AddToField.@addnt","page":"AddToField.jl","title":"AddToField.@addnt","text":"@addnt(body)\n\nCreate a named tuple using @add statments inside body.\n\nUsage\n\nWithin body, you can create a namedtuple with the following syntaxes.\n\n@add x: The named tuple will contain the field :x with the value of x.\n@add x, y, z: The named tuple will contain the fields x, y, and z with  their corresponding values.\n@add x = expr: The named tuple will contain the field :x with the value of  expr. The variable x will still be created.\n@add \"My value\" x: The named tuple will contain the field Symbol(\"My value)  with the value of x. You can also interpolate values inside the String  name.\n@add \"My value\" x = expr: The named tuple will contain the field  Symbol(\"My value\") with the value of expr. The variable x will still be created.\n\nExample:\n\njulia> s = \"My long name\";\n\njulia> res = @addnt begin\n\t\ta = 1\n\t\t@add a\n\n\t\tf, g, h = 6, 7, 8\n\t\t@add f, g, h\n\n\t\t@add b = 2\n\t\t@add :c1 c = 3\n\t\t@add \"d1\" d = 4\n\t\t@add \"My long name\" e = 5\n\tend\nend\n(a = 1, f = 6, g = 7, h = 8, b = 2, c1 = 3, d1 = 4, My long name = 5)\n\nnote: Note\nYou cannot use @add in new scopes created with body. The following will fail```julia\n\n@addnt begin \tlet \t    a = 1 \t    @add a \tend end     ```\n\nThis is because `@addnt` creates anonymous variables,\nthen constructs the named tuple at the end of the\nexpression.\n\n\n\n\n\n","category":"macro"},{"location":"","page":"AddToField.jl","title":"AddToField.jl","text":"@addto!","category":"page"},{"location":"#AddToField.@addto!","page":"AddToField.jl","title":"AddToField.@addto!","text":"@addto!(x, body)\n\nSet properties or indices of x using @add statments inside body.\n\nUsage\n\nWithin body, you can add properies or indices of x with the following.\n\n@add x: The named tuple will contain the field :x with the value of x.\n@add x, y, z: The named tuple will contain the fields x, y, and z  with their corresponding values.\n@add x = expr: The named tuple will contain the field :x with the value of  expr. The variable x will still be created.\n@add \"My value\" x: The named tuple will contain the field Symbol(\"My value)  with the value of x. You can also interpolate values inside the String  name.\n@add \"My value\" x = expr: The named tuple will contain the field  Symbol(\"My value\") with the value of expr. The variable x will still be created.\n\n@addto! defaults to calling setproperty! on x. However with AbstractDict, it calls setindex! with Symbols. Wieh AbstractDict{<:AbstractString} is calls setindex! with Strings.\n\nExample:\n\njulia> D = Dict();\n\njulia> s = \"My long name\";\n\njulia> res = @addto! D begin\n\t\ta = 1\n\t\t@add a\n\n\t\tf, g, h = 6, 7, 8\n\t\t@add f, g, h\n\n\t\t@add b = 2\n\t\t@add :c1 c = 3\n\t\t@add \"d1\" d = 4\n\t\t@add \"My long name\" e = 5\n\tend\nend\nDict{Any,Any} with 8 entries:\n  :a                     => 1\n  :f                     => 6\n  :b                     => 2\n  :h                     => 8\n  :g                     => 7\n  :d1                    => 4\n  :c1                    => 3\n  Symbol(\"My long name\") => 5\n\nnote: Note\nYou cannot use @addto! in new scopes created with body. The following will fail```julia\n\n@addto! D begin \tlet \t    a = 1 \t    @add a \tend end     ```\n\nThis is because `@addto!` creates anonymous variables,\nthen constructs the `setproperty!` or `setindex!` calls\nat the end of the expression.\n\n\n\n\n\n","category":"macro"}]
}
